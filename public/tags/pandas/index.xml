<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>pandas on Aaron&#39;s D4ta blog</title>
    <link>https://drwaterx.github.io/til/tags/pandas/</link>
    <description>Recent content in pandas on Aaron&#39;s D4ta blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Nov 2022 11:21:31 -0500</lastBuildDate><atom:link href="https://drwaterx.github.io/til/tags/pandas/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>When slicing goes awry</title>
      <link>https://drwaterx.github.io/til/posts/slices_awry/</link>
      <pubDate>Tue, 15 Nov 2022 11:21:31 -0500</pubDate>
      
      <guid>https://drwaterx.github.io/til/posts/slices_awry/</guid>
      <description>Slicing In this post, I briefly review a few methods to select rows and/or columns of a DataFrame that satisfy one or more criteria. I then introduce an additional requirement that arises frequently in practice, that being slicing with previously unknown criteria.
Levering multiIndexes I often find pandas&amp;rsquo; multiIndex to be more helpful than its rare use among colleagues would suggest.
Pandas&amp;rsquo; .xs method is a clean way to select instances, as it can be executed in a piecewise sequence of criteria.</description>
    </item>
    
    <item>
      <title>Adventures in aggregation: Part 1</title>
      <link>https://drwaterx.github.io/til/posts/gbadventures01/</link>
      <pubDate>Fri, 12 Aug 2022 15:14:44 -0500</pubDate>
      
      <guid>https://drwaterx.github.io/til/posts/gbadventures01/</guid>
      <description>It&amp;rsquo;s impossible to include an associated field value alongside an aggregate of another variable The mind sometimes has a way of creating a sensible objective that is non-sensical to a machine. We want to tabulate the make of the most expensive car in teh same row as its price. When you use the .agg method with a dictionary, you can end up with misaligned columns
df = pd.DataFrame({&amp;#39;Sector&amp;#39;: [&amp;#39;auto&amp;#39;, &amp;#39;auto&amp;#39;, &amp;#39;auto&amp;#39;], &amp;#39;c&amp;#39;: [&amp;#39;ACME&amp;#39;, &amp;#39;GM&amp;#39;, &amp;#39;FORD&amp;#39;], &amp;#39;am&amp;#39;: [20.</description>
    </item>
    
    <item>
      <title>Adventures in aggregation: Part 2</title>
      <link>https://drwaterx.github.io/til/posts/gbadventures02/</link>
      <pubDate>Fri, 22 Jul 2022 14:34:27 -0500</pubDate>
      
      <guid>https://drwaterx.github.io/til/posts/gbadventures02/</guid>
      <description>Applying a function to a groupby object: Index implications While there are multiple syntaxes and methods to produce the same aggregated data, those variations produce different indices. The format and contents of the index can impact other processes, such as serialization and deserialization.
Consider the following artificial transactional data.
txns = pd.concat([pd.DataFrame({&amp;#39;dt&amp;#39;: pd.date_range(&amp;#34;2022&amp;#34;, freq=&amp;#34;D&amp;#34;, periods=10), &amp;#39;amount&amp;#39;: np.random.random(10), &amp;#39;segment&amp;#39;: [&amp;#39;ex&amp;#39;] * 10})] * 10, axis=0) dt amount segment (Timestamp(&amp;lsquo;2022-01-01 00:00:00&amp;rsquo;), 0) 2022-01-01 00:00:00 0.</description>
    </item>
    
  </channel>
</rss>
