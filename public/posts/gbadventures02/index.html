<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Aggregation: Implications of indexing | Aaron&#39;s D4ta blog</title>
<meta name="keywords" content="pandas, data management">
<meta name="description" content="While there are multiple syntaxes and methods to produce the same aggregated data, those variations produce different indices. The format and contents of the index can impact other processes, such as serialization and deserialization.
Consider the following artificial transactional data.
txns = pd.concat([pd.DataFrame({&#39;dt&#39;: pd.date_range(&#34;2022&#34;, freq=&#34;D&#34;, periods=10), &#39;amount&#39;: np.random.random(10), &#39;segment&#39;: [&#39;ex&#39;] * 10})] * 10, axis=0) dt amount segment (Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0) 2022-01-01 00:00:00 0.">
<meta name="author" content="Aaron Slowey">
<link rel="canonical" href="https://drwaterx.github.io/til/posts/gbadventures02/">
<link crossorigin="anonymous" href="/til/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/til/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://drwaterx.github.io/til/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://drwaterx.github.io/til/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://drwaterx.github.io/til/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://drwaterx.github.io/til/apple-touch-icon.png">
<link rel="mask-icon" href="https://drwaterx.github.io/til/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<meta property="og:title" content="Aggregation: Implications of indexing" />
<meta property="og:description" content="While there are multiple syntaxes and methods to produce the same aggregated data, those variations produce different indices. The format and contents of the index can impact other processes, such as serialization and deserialization.
Consider the following artificial transactional data.
txns = pd.concat([pd.DataFrame({&#39;dt&#39;: pd.date_range(&#34;2022&#34;, freq=&#34;D&#34;, periods=10), &#39;amount&#39;: np.random.random(10), &#39;segment&#39;: [&#39;ex&#39;] * 10})] * 10, axis=0) dt amount segment (Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0) 2022-01-01 00:00:00 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://drwaterx.github.io/til/posts/gbadventures02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-22T14:34:27-05:00" />
<meta property="article:modified_time" content="2022-07-22T14:34:27-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Aggregation: Implications of indexing"/>
<meta name="twitter:description" content="While there are multiple syntaxes and methods to produce the same aggregated data, those variations produce different indices. The format and contents of the index can impact other processes, such as serialization and deserialization.
Consider the following artificial transactional data.
txns = pd.concat([pd.DataFrame({&#39;dt&#39;: pd.date_range(&#34;2022&#34;, freq=&#34;D&#34;, periods=10), &#39;amount&#39;: np.random.random(10), &#39;segment&#39;: [&#39;ex&#39;] * 10})] * 10, axis=0) dt amount segment (Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0) 2022-01-01 00:00:00 0."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://drwaterx.github.io/til/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Aggregation: Implications of indexing",
      "item": "https://drwaterx.github.io/til/posts/gbadventures02/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Aggregation: Implications of indexing",
  "name": "Aggregation: Implications of indexing",
  "description": "While there are multiple syntaxes and methods to produce the same aggregated data, those variations produce different indices. The format and contents of the index can impact other processes, such as serialization and deserialization.\nConsider the following artificial transactional data.\ntxns = pd.concat([pd.DataFrame({\u0026#39;dt\u0026#39;: pd.date_range(\u0026#34;2022\u0026#34;, freq=\u0026#34;D\u0026#34;, periods=10), \u0026#39;amount\u0026#39;: np.random.random(10), \u0026#39;segment\u0026#39;: [\u0026#39;ex\u0026#39;] * 10})] * 10, axis=0) dt amount segment (Timestamp(\u0026lsquo;2022-01-01 00:00:00\u0026rsquo;), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(\u0026lsquo;2022-01-01 00:00:00\u0026rsquo;), 0) 2022-01-01 00:00:00 0.",
  "keywords": [
    "pandas", "data management"
  ],
  "articleBody": "While there are multiple syntaxes and methods to produce the same aggregated data, those variations produce different indices. The format and contents of the index can impact other processes, such as serialization and deserialization.\nConsider the following artificial transactional data.\ntxns = pd.concat([pd.DataFrame({'dt': pd.date_range(\"2022\", freq=\"D\", periods=10), 'amount': np.random.random(10), 'segment': ['ex'] * 10})] * 10, axis=0) dt amount segment (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex Our primary objective is to produce a table of the highest amounts for one or more days. In this exercise, we try different approaches and pick one that yields the desired index. With any approach, .groupby places the grouping variable into the index of any aggregated DataFrame.\nApply a lambda function directly to the groupby object (gbo), in which x is the row of the aggregated DataFrame per the gbo directive. In this approach, we specify the column(s) with which to rank the instances. If present, other columns will be returned…\n(txns.groupby('dt').apply(lambda x: x.nlargest(3, 'amount')) )[0:9] dt amount segment (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex …Unless we follow that operation with a selection:\n(txns.groupby('dt').apply(lambda x: x.nlargest(3, 'amount')) .loc[:, 'amount'] )[0:9] amount (Timestamp(‘2022-01-01 00:00:00’), 0) 0.992821 (Timestamp(‘2022-01-01 00:00:00’), 0) 0.992821 (Timestamp(‘2022-01-01 00:00:00’), 0) 0.992821 (Timestamp(‘2022-01-02 00:00:00’), 1) 0.954333 (Timestamp(‘2022-01-02 00:00:00’), 1) 0.954333 (Timestamp(‘2022-01-02 00:00:00’), 1) 0.954333 (Timestamp(‘2022-01-03 00:00:00’), 2) 0.489229 (Timestamp(‘2022-01-03 00:00:00’), 2) 0.489229 (Timestamp(‘2022-01-03 00:00:00’), 2) 0.489229 Either way, nlargest provides dt as the DataFrame index. If we want to serialize as JSON in a bundle of other objects (covered elsewhere), we need to convert the data to a dictionary. Note that .to_dict ignores the index, so .reset_index().\nNotice how, in both of the previous two examples, the grouping variable _ combines_ with the original index to form a MultiIndex:\ntxnsg = (txns.groupby('dt').apply(lambda x: x.nlargest(3, 'amount')) )[0:9] print(txnsg.index) MultiIndex([('2022-01-01', 0), ('2022-01-01', 0), ('2022-01-01', 0), ('2022-01-02', 1), ('2022-01-02', 1), ('2022-01-02', 1), ('2022-01-03', 2), ('2022-01-03', 2), ('2022-01-03', 2)], names=['dt', None]) Before determining the downstream implications of this MultiIndex, note that we can produce the same output by reversing the lambda application with the column selection:\ntxns.groupby('dt')['amount'].apply(lambda x: x.nlargest(3)) dt 2022-01-01 0 0.992821 0 0.992821 0 0.992821 2022-01-02 1 0.954333 1 0.954333 1 0.954333 2022-01-03 2 0.489229 2 0.489229 2 0.489229 2022-01-04 3 0.234701 3 0.234701 3 0.234701 2022-01-05 4 0.695798 4 0.695798 4 0.695798 If returning a multiIndexed DataFrame by a groupby seems unexpected, you’re not alone. It only happens when .groupby is used with .apply, via the group_keys=True default argument. If group_keys=False, only the original indices are retained:\n(txns.groupby('dt', group_keys=False) .apply(lambda x: x.nlargest(3, 'amount')) .loc[:, 'amount'] )[0:9] 0 0.992821 0 0.992821 0 0.992821 1 0.954333 1 0.954333 1 0.954333 2 0.489229 2 0.489229 2 0.489229 Another variation is whether to retain the grouping variable values as_index=True (default) or replace them with integer indices as_index=False:\n(txns.groupby('dt', as_index=False, group_keys=True).apply( lambda x: x.nlargest(3, 'amount')) .loc[:, 'amount'] )[0:9] 0 0 0.992821 0 0.992821 0 0.992821 1 1 0.954333 1 0.954333 1 0.954333 2 2 0.489229 2 0.489229 2 0.489229 When we write a multi-indexed DataFrame or Series with .to_csv, it will put commas after level 0 and the nameless integer index (level 1). Remember, such multiIndexing only happens when .groupby is used with .apply, via the group_keys=True default, such that they will form two separate columns when opened in Excel or loaded by .read_csv. The issue is that level 1 remains nameless–a blank column header–in Excel. But notice that, upon reading the file, pandas provides the name Unnamed: 1 (note also dt.1):\ntxnsg.to_csv('multi_indexed_csv_test.csv') reload = pd.read_csv('multi_indexed_csv_test.csv') dt Unnamed: 1 dt.1 amount segment 0 2022-01-01 0 2022-01-01 0.992821 ex 1 2022-01-01 0 2022-01-01 0.992821 ex 2 2022-01-01 0 2022-01-01 0.992821 ex 3 2022-01-02 1 2022-01-02 0.954333 ex 4 2022-01-02 1 2022-01-02 0.954333 ex 5 2022-01-02 1 2022-01-02 0.954333 ex 6 2022-01-03 2 2022-01-03 0.489229 ex 7 2022-01-03 2 2022-01-03 0.489229 ex 8 2022-01-03 2 2022-01-03 0.489229 ex To ensure index levels are consistently labeled, give any unnamed levels a name with the .rename_axis method:\n(txns.rename_axis('txn_id') .groupby('dt') .apply(lambda x: x.nlargest(3, 'amount')) )[0:9] dt amount segment (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-01 00:00:00’), 0) 2022-01-01 00:00:00 0.992821 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-02 00:00:00’), 1) 2022-01-02 00:00:00 0.954333 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex (Timestamp(‘2022-01-03 00:00:00’), 2) 2022-01-03 00:00:00 0.489229 ex The exported csv of the dataframe above will have all columns labeled. But what if, before the groupby operation, we slice the data with values contained in a non-index field (other than txn_id)? We must .set_index('slicer_col') before slicing the dataframe with those values, which typically would be in a pd.Index instance (idx, say) and applied via .loc[idx].\nWhether we rename a pre-existing index or not, if we set the index with another column, that previous index will be lost, unless it is reset into columns.\n",
  "wordCount" : "924",
  "inLanguage": "en",
  "datePublished": "2022-07-22T14:34:27-05:00",
  "dateModified": "2022-07-22T14:34:27-05:00",
  "author":{
    "@type": "Person",
    "name": "Aaron Slowey"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://drwaterx.github.io/til/posts/gbadventures02/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Aaron's D4ta blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://drwaterx.github.io/til/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://drwaterx.github.io/til/" accesskey="h" title="Aaron&#39;s D4ta blog (Alt + H)">Aaron&#39;s D4ta blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://drwaterx.github.io/til/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://drwaterx.github.io/til/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Aggregation: Implications of indexing
    </h1>
    <div class="post-meta"><span title='2022-07-22 14:34:27 -0500 -0500'>July 22, 2022</span>&nbsp;·&nbsp;Aaron Slowey

</div>
  </header> 
  <div class="post-content"><p>While there are multiple syntaxes and methods to produce the same aggregated
data, those variations produce different indices. The format and contents of the
index can impact other processes, such as serialization and deserialization.</p>
<p>Consider the following artificial transactional data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>txns <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>concat([pd<span style="color:#f92672">.</span>DataFrame({<span style="color:#e6db74">&#39;dt&#39;</span>: pd<span style="color:#f92672">.</span>date_range(<span style="color:#e6db74">&#34;2022&#34;</span>, freq<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;D&#34;</span>, periods<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>),
</span></span><span style="display:flex;"><span>                                <span style="color:#e6db74">&#39;amount&#39;</span>: np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>random(<span style="color:#ae81ff">10</span>),
</span></span><span style="display:flex;"><span>                                <span style="color:#e6db74">&#39;segment&#39;</span>: [<span style="color:#e6db74">&#39;ex&#39;</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>})] <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">dt</th>
<th style="text-align:right">amount</th>
<th style="text-align:left">segment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
</tbody>
</table>
<p>Our primary objective is to produce a table of the highest amounts for one or
more days. In this exercise, we try different approaches and pick one that
yields the desired index. With any approach, <code>.groupby</code> places the grouping
variable into the index of any aggregated DataFrame.</p>
<p>Apply a <code>lambda</code> function directly to the groupby object (gbo), in which <code>x</code>
is the row of the <em>aggregated</em> <code>DataFrame</code> per the gbo directive. In this
approach, we specify the column(s) with which to rank the instances. If
present, other columns will be returned&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(txns<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;dt&#39;</span>)<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>nlargest(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;amount&#39;</span>))
</span></span><span style="display:flex;"><span> )[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">9</span>]
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">dt</th>
<th style="text-align:right">amount</th>
<th style="text-align:left">segment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
</tbody>
</table>
<p>&hellip;<em>Unless</em> we follow that operation with a selection:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(txns<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;dt&#39;</span>)<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>nlargest(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;amount&#39;</span>))
</span></span><span style="display:flex;"><span> <span style="color:#f92672">.</span>loc[:, <span style="color:#e6db74">&#39;amount&#39;</span>]
</span></span><span style="display:flex;"><span> )[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">9</span>]
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:right">amount</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:right">0.992821</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:right">0.992821</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:right">0.992821</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:right">0.954333</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:right">0.954333</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:right">0.954333</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:right">0.489229</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:right">0.489229</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:right">0.489229</td>
</tr>
</tbody>
</table>
<p>Either way, <code>nlargest</code> provides <code>dt</code> as the <code>DataFrame</code> index. If we
want to serialize as JSON in a bundle of other objects (covered elsewhere), we
need to convert the data to a dictionary. Note that <code>.to_dict</code> ignores the
index, so <code>.reset_index()</code>.</p>
<p>Notice how, in both of the previous two examples, the grouping variable _
combines_ with the original index to form a <code>MultiIndex</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>txnsg <span style="color:#f92672">=</span> (txns<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;dt&#39;</span>)<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>nlargest(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;amount&#39;</span>))
</span></span><span style="display:flex;"><span>        )[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">9</span>]
</span></span><span style="display:flex;"><span>print(txnsg<span style="color:#f92672">.</span>index)
</span></span></code></pre></div><pre tabindex="0"><code>MultiIndex([(&#39;2022-01-01&#39;, 0),
            (&#39;2022-01-01&#39;, 0),
            (&#39;2022-01-01&#39;, 0),
            (&#39;2022-01-02&#39;, 1),
            (&#39;2022-01-02&#39;, 1),
            (&#39;2022-01-02&#39;, 1),
            (&#39;2022-01-03&#39;, 2),
            (&#39;2022-01-03&#39;, 2),
            (&#39;2022-01-03&#39;, 2)],
           names=[&#39;dt&#39;, None])
</code></pre><p>Before determining the downstream implications of this <code>MultiIndex</code>, note that
we can produce the same output by reversing the <code>lambda</code> application with the
column selection:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>txns<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;dt&#39;</span>)[<span style="color:#e6db74">&#39;amount&#39;</span>]<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>nlargest(<span style="color:#ae81ff">3</span>))
</span></span></code></pre></div><pre tabindex="0"><code class="language-table" data-lang="table">dt           
2022-01-01  0    0.992821
            0    0.992821
            0    0.992821
2022-01-02  1    0.954333
            1    0.954333
            1    0.954333
2022-01-03  2    0.489229
            2    0.489229
            2    0.489229
2022-01-04  3    0.234701
            3    0.234701
            3    0.234701
2022-01-05  4    0.695798
            4    0.695798
            4    0.695798
</code></pre><p>If returning a multiIndexed <code>DataFrame</code> by a <code>groupby</code> seems unexpected, you&rsquo;re
not alone. It only happens when <code>.groupby</code> is used with <code>.apply</code>, via
the <code>group_keys=True</code> default argument. If <code>group_keys=False</code>, only the original
indices are retained:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(txns<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;dt&#39;</span>, group_keys<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>nlargest(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;amount&#39;</span>))
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">.</span>loc[:, <span style="color:#e6db74">&#39;amount&#39;</span>]
</span></span><span style="display:flex;"><span>)[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">9</span>]
</span></span></code></pre></div><pre tabindex="0"><code class="language-table" data-lang="table">0    0.992821
0    0.992821
0    0.992821
1    0.954333
1    0.954333
1    0.954333
2    0.489229
2    0.489229
2    0.489229
</code></pre><p>Another variation is whether to retain the grouping variable
values <code>as_index=True</code> (default) or replace them with integer
indices <code>as_index=False</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(txns<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;dt&#39;</span>, as_index<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, group_keys<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>apply(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>nlargest(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;amount&#39;</span>))
</span></span><span style="display:flex;"><span> <span style="color:#f92672">.</span>loc[:, <span style="color:#e6db74">&#39;amount&#39;</span>]
</span></span><span style="display:flex;"><span> )[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">9</span>]
</span></span></code></pre></div><pre tabindex="0"><code class="language-table" data-lang="table">0  0    0.992821
   0    0.992821
   0    0.992821
1  1    0.954333
   1    0.954333
   1    0.954333
2  2    0.489229
   2    0.489229
   2    0.489229
</code></pre><p>When we write a multi-indexed DataFrame or Series with <code>.to_csv</code>, it will put
commas after level 0 and the <em>nameless</em> integer index (level 1). Remember, such
multiIndexing only happens when <code>.groupby</code> is used with <code>.apply</code>, via
the <code>group_keys=True</code> default, such that they will form two separate columns
when opened in Excel or loaded by <code>.read_csv</code>. The issue is that level 1 remains
nameless&ndash;a blank column header&ndash;in Excel. But notice that, upon reading the
file, pandas provides the name <code>Unnamed: 1</code> (note also <code>dt.1</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>txnsg<span style="color:#f92672">.</span>to_csv(<span style="color:#e6db74">&#39;multi_indexed_csv_test.csv&#39;</span>)
</span></span><span style="display:flex;"><span>reload <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_csv(<span style="color:#e6db74">&#39;multi_indexed_csv_test.csv&#39;</span>)
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:left">dt</th>
<th style="text-align:right">Unnamed: 1</th>
<th style="text-align:left">dt.1</th>
<th style="text-align:right">amount</th>
<th style="text-align:left">segment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:left">2022-01-01</td>
<td style="text-align:right">0</td>
<td style="text-align:left">2022-01-01</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:left">2022-01-01</td>
<td style="text-align:right">0</td>
<td style="text-align:left">2022-01-01</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:left">2022-01-01</td>
<td style="text-align:right">0</td>
<td style="text-align:left">2022-01-01</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:left">2022-01-02</td>
<td style="text-align:right">1</td>
<td style="text-align:left">2022-01-02</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:left">2022-01-02</td>
<td style="text-align:right">1</td>
<td style="text-align:left">2022-01-02</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:right">5</td>
<td style="text-align:left">2022-01-02</td>
<td style="text-align:right">1</td>
<td style="text-align:left">2022-01-02</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:right">6</td>
<td style="text-align:left">2022-01-03</td>
<td style="text-align:right">2</td>
<td style="text-align:left">2022-01-03</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:right">7</td>
<td style="text-align:left">2022-01-03</td>
<td style="text-align:right">2</td>
<td style="text-align:left">2022-01-03</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:right">8</td>
<td style="text-align:left">2022-01-03</td>
<td style="text-align:right">2</td>
<td style="text-align:left">2022-01-03</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
</tbody>
</table>
<p>To ensure index levels are consistently labeled, give any unnamed levels a name
with the <code>.rename_axis</code> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(txns<span style="color:#f92672">.</span>rename_axis(<span style="color:#e6db74">&#39;txn_id&#39;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;dt&#39;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>nlargest(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;amount&#39;</span>))
</span></span><span style="display:flex;"><span> )[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">9</span>]
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">dt</th>
<th style="text-align:right">amount</th>
<th style="text-align:left">segment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-01 00:00:00&rsquo;), 0)</td>
<td style="text-align:left">2022-01-01 00:00:00</td>
<td style="text-align:right">0.992821</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-02 00:00:00&rsquo;), 1)</td>
<td style="text-align:left">2022-01-02 00:00:00</td>
<td style="text-align:right">0.954333</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
<tr>
<td style="text-align:left">(Timestamp(&lsquo;2022-01-03 00:00:00&rsquo;), 2)</td>
<td style="text-align:left">2022-01-03 00:00:00</td>
<td style="text-align:right">0.489229</td>
<td style="text-align:left">ex</td>
</tr>
</tbody>
</table>
<p>The exported csv of the dataframe above will have all columns labeled. But what
if, before the groupby operation, we slice the data with values contained in a
non-index field (other than <code>txn_id</code>)? We
must <code>.set_index('slicer_col')</code> before slicing the dataframe with those values,
which typically would be in a <code>pd.Index</code> instance (<code>idx</code>, say) and applied
via <code>.loc[idx]</code>.</p>
<p>Whether we rename a pre-existing index or not, if we set the index with another
column, that previous index will be lost, unless it is reset into columns.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://drwaterx.github.io/til/tags/pandas/">pandas</a></li>
      <li><a href="https://drwaterx.github.io/til/tags/data-management/">data management</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://drwaterx.github.io/til/">Aaron&#39;s D4ta blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
